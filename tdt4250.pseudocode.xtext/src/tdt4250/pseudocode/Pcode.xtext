// automatically generated by Xtext
grammar tdt4250.pseudocode.Pcode with org.eclipse.xtext.common.Terminals

import "platform:/plugin/tdt4250.pseudocode.model/model/pseudocode.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

//generate pseudocode "http://www.pseudocode.tdt4250/xtext/Pcode"


/* Da burde det meste fungere ;) 
 * Da er det bare å gå i gang med å generere kode ;)
 * Dette gjøres i tdt4250.pseudocode.generator pakken!
 */


Model returns Model:
	{Model}
	functions+=Function*
;

Function:
	{Function}
	name=EString
	'('
	(parameters+=Parameter ("," parameters+=Parameter)*)*		
	')'
	//('\n' ('\n')*)
	BEGIN
		features+=Feature*
	END;

Feature:
	Statement | Expression
;

Statement:
	IfExpression | ForExpression | WhileExpression | Stop
;

Expression returns Expression:
	Variable |
	Print | 
	CollectionAdd |
	CollectionRemove |
	ValueExchange
;

Variable returns Expression:
	{Variable} name=ID ('=' | 'equals' | 'is') value=(LiteralExpression);


Parameter returns Expression: 
	{Variable} name=ID;

IfExpression returns IfExpression:
	{IfExpression}
	name='if' condition=LiteralExpression ('then')?
	BEGIN
		then+=Feature*
	END
    (=>'else' 
    BEGIN
		else+=Feature*
	END
    )?
;

ForExpression returns ForExpression:
	{ForExpression}
	'for' ('interval')? from=ArithmeticExpression 'to' to=ArithmeticExpression
	BEGIN
		block+=Feature*
	END
;


WhileExpression returns WhileExpression:
	{WhileExpression}
	'while' condition=LiteralExpression
	BEGIN
		block+=Feature*
	END
;


Stop returns Stop:
	{Stop}
	(type=('stop'| 'break'| 'continue') | (type='return' value=Type))
;


Print:
	name='print' value=LiteralExpression
;

CollectionAdd returns Expression:
	{CollectionAdd}
	collection=[Variable] 'add' value=LiteralExpression
;

CollectionRemove returns Expression:
	{CollectionAdd}
	collection=[Variable] 'remove' value=LiteralExpression
;

ValueExchange returns Expression:
	{ValueExchange}
	'exchange' collection=LiteralExpression 'with' value=LiteralExpression
;

FunctionCall:
	{FunctionCall}
	name=EString '(' (parameters+=Parameter ("," parameters+=Parameter)*)? ')';


// Indentation
terminal BEGIN: 'synthetic:BEGIN';
terminal END: 'synthetic:END';

// -- Literal Expressions ---

LiteralExpression returns Expression:
	Collection |
	CollectionAccessor |
	BooleanExpression;


Collection returns Expression:
	CollectionLitteral | List
;

List returns Expression:
	{List}
	'a'? 'new' type=('text' | 'number' | 'decimal') ('array' | 'list' | 'table')
	('and' 'contains' elements+=LiteralExpression (',' elements+=LiteralExpression )* )? 
;

CollectionLitteral returns Expression:
	SetLitteral | ListLitteral
;

SetLitteral returns Expression:
	{SetLitteral}
	'{' (elements+=LiteralExpression (',' elements+=LiteralExpression )*)? '}'
;

ListLitteral returns Expression:
	{ListLitteral}
	'[' (elements+=LiteralExpression (',' elements+=LiteralExpression )*)? ']'
;

CollectionAccessor returns Expression:
	{CollectionAccessor}
	// TODO? "variables/scopes/CollectionAccessor etc should inherit from same class to be able to generate appropriate code?
	 (
	 	collection=[Variable] ('['accessor+=LiteralExpression']')+ |

		// used instead of list[i]. Eks. list[i][j]  equals list at i,j 
	 	collection=[Variable] 'at' ('index')? accessor+=LiteralExpression (',' accessor+=LiteralExpression )*
	 );

//----- Logic and Math------

BooleanExpression returns Expression:
	Comparison 
	(({AndOrExpression.left=current} op=("||"|"&&")) right=Comparison)*;

Comparison returns Expression:
       Equals
       (({Comparison.left=current} op=('<' | '>')) right=Equals)*;

Equals returns Expression:
       Addition 
       (({Equals.left=current} op=('==' |'<=' | '>=' | '!=')) right=Addition)*;
 
ArithmeticExpression returns Expression: 
	Addition
;

 
Addition returns Expression:
	Multiplication (({Plus.left=current} PlusOperator | {Minus.left=current} ('-' | 'minus')) right=Multiplication)*; 

PlusOperator:
	('+' | 'plus')
;

Multiplication returns Expression:
	Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
	{BooleanNegation} =>"!" expression=Atomic | /* right associativity */
	{ArithmeticSigned} =>('-' | 'minus') expression=Atomic | /* right associativity */
	Atomic;

Atomic returns Expression:
	'(' Expression ')' |
	{NumberLiteral} value=INT |
	{StringLiteral} value=STRING |
	{BooleanLiteral} value=('true'|'false') |
	{VariableReference} ref=[Variable]  |
	FunctionCall;

// --- Diff ---

BooleanOperator:
	'&&' | '||' | '!' | '^'
;

BooleanTestOperator:
	'==' |'<' |'<=' | '>' | '>=' | '!='
;

Type:
	(EString | DOUBLE | INT)
;

EString returns ecore::EString:
	STRING | ID;
	
terminal DOUBLE:
    INT '.' INT;
