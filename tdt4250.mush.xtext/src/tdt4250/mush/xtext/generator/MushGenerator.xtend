/*
 * generated by Xtext 2.22.0
 */
package tdt4250.mush.xtext.generator

import java.util.ArrayList
import java.util.HashSet
import java.util.StringJoiner
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import tdt4250.mush.model.AndOrExpression
import tdt4250.mush.model.ArithmeticSigned
import tdt4250.mush.model.BooleanLiteral
import tdt4250.mush.model.BooleanNegation
import tdt4250.mush.model.CollectionAccessor
import tdt4250.mush.model.CollectionAdd
import tdt4250.mush.model.CollectionRemove
import tdt4250.mush.model.Comparison
import tdt4250.mush.model.DoubleLiteral
import tdt4250.mush.model.Equals
import tdt4250.mush.model.Expression
import tdt4250.mush.model.ForStatement
import tdt4250.mush.model.Function
import tdt4250.mush.model.FunctionCall
import tdt4250.mush.model.IfStatement
import tdt4250.mush.model.List
import tdt4250.mush.model.ListLitteral
import tdt4250.mush.model.Minus
import tdt4250.mush.model.Model
import tdt4250.mush.model.MultiOrDiv
import tdt4250.mush.model.NumberLiteral
import tdt4250.mush.model.ParenthesizedExpression
import tdt4250.mush.model.Plus
import tdt4250.mush.model.Print
import tdt4250.mush.model.SetLitteral
import tdt4250.mush.model.Statement
import tdt4250.mush.model.Stop
import tdt4250.mush.model.StringLiteral
import tdt4250.mush.model.ValueExchange
import tdt4250.mush.model.Variable
import tdt4250.mush.model.VariableReference
import tdt4250.mush.model.WhileStatement
import tdt4250.mush.model.SizeExpression
import tdt4250.mush.model.CollectionSet

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MushGenerator extends AbstractGenerator {

    var typeInferencer = new MushTypeInferencer()
    var varCounter = 0
    var varList = new ArrayList<String>
    var importTypes = new HashSet<String>
    var packageName = ''

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

        for (e : resource.allContents.toIterable.filter(Function)) {
            varCounter = 0 // Reset counter
            varList.clear() // Empty variable list
            importTypes.clear() // Empty import list
            packageName = null
            packageName = (e.eContainer as Model).package
            var folder = ''
            if (packageName !== null) {
                folder += packageName.replace('.', '/') + '/'
            }
            var res = e.generate
            fsa.generateFile(folder + e.name + '.java', res)
        }
    }

    def generate(Function e) {
        var string = ''
        var type = typeInferencer.infer(e)
        var params = ''
        if (!e.parameters.isEmpty) {
            params += e.parameters.generateParameters
        }
        var body = ''
        for (f : e.features) {
            body += f.generateFeature
        }

        var main = ''
        if(e.executable) main = generateMainFunction(e)

        if (packageName !== null) {
            string += 'package ' + packageName + ';\n\n'    
        } 
        
        for (importType : importTypes) {
        	string += 'import ' + importType + ';\n'
        }
        if (!importTypes.isEmpty) string += '\n'

        string += '''
            public class «e.name» {
                public static «type» run(«params») {
                    «body»
                }
                
                «main»
            }
        '''
        return string
    }

    def generateMainFunction(Function function) {
        var string = ''
        var argString = ''
        var argList = new StringJoiner(",");

        if (!function.parameters.isEmpty) {
            for (var i = 0; i < function.parameters.length; i++) {
                var param = function.parameters.get(i)
                val variable = param as Variable
                val type = typeInferencer.infer(variable.type)
                val convertedType = generateTypeConvertionCode('args[' + i + ']', type)

                var arg = 'ARG' + i
                argString += type + ' ' + arg + ' = ' + convertedType + ';\n'

                argList.add(arg)
            }
        }

        string += '''
            public static void main(final String[] args) {
                «argString»
                run(«argList.toString»);
            }
        '''
    }

    def generateTypeConvertionCode(String value, String type) {
        switch (type) {
            case 'String':
                return value
            case 'int':
                return 'Integer.parseInt(' + value + ')'
            case 'double':
                return 'Double.parseDouble(' + value + ')'
            case 'boolean':
                return 'Boolean.parseBoolean(' + value + ')'
            default: {
                return value
            }
        }
    }

    def generateParameters(EList<Expression> variables) {
        var parameters = ""
        for (v : variables) {
            val variable = v as Variable
            val type = typeInferencer.infer(variable.type)
            // if( !varList.contains(variable.name)){ parameters += typeInferencer.toJvmType(type.name) + " " + variable.name + ", "}
            var param = typeInferencer.toJvmType(type) + " " + variable.name + ", "
            parameters += param
            if(param.contains('List')) importTypes.add('java.util.List')
            if(param.contains('Set')) importTypes.add('java.util.Set')
            varList.add(variable.name)
        }
        parameters = parameters.substring(0, parameters.length - 2)
        return parameters
    }

    def dispatch generateFeature(Statement e) '''
    «e.generateStatement»'''

    def dispatch generateFeature(Expression e) '''
    «e.generateExpression»'''

    def dispatch generateStatement(IfStatement e) '''
        if («e.condition.LiteralExpression») {
            «FOR f : e.then»
                «f.generateFeature»
            «ENDFOR»
        }«IF !e.otherwise.isEmpty» else {
            «FOR f2 : e.otherwise»«f2.generateFeature»«ENDFOR»
        }«ENDIF»
    '''

    def dispatch generateStatement(ForStatement e) {
        var variable = uniqueVariable();
        return '''
            for (int «variable» = «e.from.LiteralExpression»; «variable» <= «e.to.LiteralExpression»; «variable»++) {
                «FOR b : e.block»
                    «b.generateFeature»
                «ENDFOR»
            }
        '''
    }

    def uniqueVariable() {
        return 'VAR' + varCounter++
    }

    def dispatch generateStatement(WhileStatement e) '''
        while («e.condition.LiteralExpression») {
            «FOR b : e.block»
                «b.generateFeature»
            «ENDFOR»
        }
    '''

    def dispatch generateStatement(Stop e) {
        var string = ''
        string += e.type.replace('stop', 'return')

        if (e.value !== null) {
            string += ' ' + e.value.LiteralExpression + ';'
        }else{
            string += ';'
        }
        return string

    }

    def printvarList() {
        var v = varList.size()
        return '''«v»'''
    }

    def dispatch generateExpression(Variable e) {
        var string = ''
        if (!varList.contains(e.name)) {
            string += typeInferencer.infer(e.value) + ' ' + e.name + ' = ' + e.value.LiteralExpression + ';'
            varList.add(e.name)
        } else {
            if (e.op.equals('++') || e.op.equals('--')) {
                string += e.name + e.op + ';'
            }else if(e.op.equals('equals')||e.op.equals('is')){
                 string += e.name + ' ' + '=' + ' ' + e.value.LiteralExpression + ';'
            } else {
                string += e.name + ' ' + e.op + ' ' + e.value.LiteralExpression + ';'
            }
        }
        return string + '\n'
    }

    def dispatch generateExpression(Print e) {
        if (e.newline) {
            return '''
                System.out.println(«e.value.LiteralExpression»);
            '''
        } else {
            return '''
                System.out.print(«e.value.LiteralExpression»);
            '''
        }
    }
    
   
    def dispatch getSet(CollectionSet e) {
        var string = ''
        if(e.left.length>1){
            string+='.get('+(e.left.get(0).LiteralExpression)+').set('+(e.left.get(1).LiteralExpression)
        }else{
            string+='.set('+(e.left.get(0).LiteralExpression)
        }
        return string
    }

    def dispatch generateExpression(CollectionAdd e) '''
    «e.collection.name».add(«e.value.LiteralExpression»);'''

    def dispatch generateExpression(CollectionRemove e) '''
    «e.collection.name».remove(«e.value.LiteralExpression»);'''

    def dispatch generateExpression(CollectionSet e) '''
    «e.collection.name»«getSet(e)»,«e.right.LiteralExpression»);'''


    def dispatch generateExpression(FunctionCall e) {
        return e.LiteralExpression + ';' + '\n'
    }

    def dispatch generateExpression(ValueExchange e) {
        var variable1 = uniqueVariable();
        var variable2 = uniqueVariable();
        var exp1 = e.collection.LiteralExpression.toString
        var exp2 = e.value.LiteralExpression.toString

        if (e.collection instanceof CollectionAccessor) {
            exp1 = MushGeneratorUtils.replaceLast('get', 'set', exp1)
            exp1 = MushGeneratorUtils.replaceLast(')', ',' + variable2 + ')', exp1)
        } else {
            exp1 = exp1 + '=' + variable2
        }

        if (e.value instanceof CollectionAccessor) {
            exp2 = MushGeneratorUtils.replaceLast('get', 'set', exp2)
            exp2 = MushGeneratorUtils.replaceLast(')', ',' + variable1 + ')', exp2)

        } else {
            exp2 = exp2 + '=' + variable1
        }

        return '''
            «typeInferencer.infer(e.collection)» «variable1» = «e.collection.LiteralExpression»;
            «typeInferencer.infer(e.value)» «variable2» = «e.value.LiteralExpression»;
            «exp1»;
            «exp2»;
        '''
    }

    // LiteralExpression
    // TODO: trim last comma ","
    def dispatch String LiteralExpression(List e) {
        var string = ''
        var listType = typeInferencer.autobox(typeInferencer.infer(e.type))
        string += 'new ArrayList<' + listType + '>'
        importTypes.add('java.util.ArrayList')
        importTypes.add('java.util.List')
        if (e.elements.isEmpty) {
            string += '()'
        } else {
            string += '(Arrays.asList('
            importTypes.add('java.util.Arrays')
            var joiner = new StringJoiner(",");
            for (element : e.elements) {
                joiner.add(element.LiteralExpression.toString)
            }
            string += joiner.toString + '))'
        }

        return string
    }

    def dispatch LiteralExpression(SetLitteral e) {
        var string = ''
        var listType = typeInferencer.autobox(typeInferencer.infer(e.elements.get(0)).toString)
        string += 'new HashSet<' + listType + '>'
        importTypes.add('java.util.HashSet')
        importTypes.add('java.util.Set')
        if (e.elements.isEmpty) {
            string += '()'
        } else {
            string += '(Arrays.asList('
            importTypes.add('java.util.Arrays')
            var joiner = new StringJoiner(",");
            for (element : e.elements) {
                joiner.add(element.LiteralExpression.toString)
            }
            string += joiner.toString + '))'
        }
        return string
    }

    // TODO: trim last comma ","
    def dispatch LiteralExpression(ListLitteral e) {
        var string = ''
        var listType = typeInferencer.autobox(typeInferencer.infer(e.elements.get(0)).toString)
        string += 'new ArrayList<' + listType + '>'
        importTypes.add('java.util.ArrayList')
        importTypes.add('java.util.List')
        if (e.elements.isEmpty) {
            string += '()'
        } else {
            string += '(Arrays.asList('
            importTypes.add('java.util.Arrays')
            var joiner = new StringJoiner(",");
            for (element : e.elements) {
                joiner.add(element.LiteralExpression.toString)
            }
            string += joiner.toString + '))'
        }
        return string
    }

    def dispatch LiteralExpression(CollectionAccessor e) {
        var string = ''
        string += e.collection.name
        for (accessor : e.accessor) {
            string += '.get(' + accessor.LiteralExpression + ')'
        }
        return string
    }

    def checkAndORType(AndOrExpression e) {
        if (e.op.equals('or'))
            return '|'
        else if(e.op.equals('and')) return '&' else return e.op
    }

    def checkMultiOrDiv(MultiOrDiv e) {
        if (e.op.equals('times'))
            return '*'
        else if(e.op.equals('divide')) return '/'
        else if(e.op.equals('modulo')) return '%'
        else return e.op
    }
    
    def checkComparison(Comparison e){
        if(e.op.equals('lessThen')) return '<'
        else if(e.op.equals('biggerThen')) return '>'
        else return e.op
    }

    def dispatch LiteralExpression(AndOrExpression e) '''
    «e.left.LiteralExpression»«checkAndORType(e)»«e.right.LiteralExpression»'''

    def dispatch LiteralExpression(Comparison e) '''
    «e.left.LiteralExpression»«checkComparison(e)»«e.right.LiteralExpression»'''

    def dispatch LiteralExpression(Equals e) '''
    «e.left.LiteralExpression»«e.op»«e.right.LiteralExpression»'''

    // ArithmeticExpression
    def dispatch LiteralExpression(ParenthesizedExpression e) '''
    («e.expression.LiteralExpression»)'''

    def dispatch LiteralExpression(Plus e) '''
    «e.left.LiteralExpression»+«e.right.LiteralExpression»'''

    def dispatch LiteralExpression(Minus e) '''
    «e.left.LiteralExpression»-«e.right.LiteralExpression»'''

    def dispatch LiteralExpression(MultiOrDiv e) '''
    «e.left.LiteralExpression»«checkMultiOrDiv(e)»«e.right.LiteralExpression»'''

    // TODO fix convert to float and support keywords divide and times
    def dispatch LiteralExpression(BooleanNegation e) '''
    !«e.expression.LiteralExpression»'''

    def dispatch LiteralExpression(ArithmeticSigned e) '''
    -«e.expression.LiteralExpression»'''

    def dispatch LiteralExpression(NumberLiteral e) { return e.value }

    def dispatch LiteralExpression(DoubleLiteral e) { return e.value }

    def dispatch LiteralExpression(StringLiteral e) { return '"' + MushGeneratorUtils.escape(e.value) + '"' }

    def dispatch LiteralExpression(BooleanLiteral e) { return e.value }

    def dispatch LiteralExpression(VariableReference e) '''
    «e.ref.name»'''

    def dispatch LiteralExpression(FunctionCall e) {
        var string = ''
        string += e.ref.name + '.run('
        var refPackageName = (e.ref.eContainer as Model).package

        // Don't add import if call is to function in current file.
        if (refPackageName !== null && !refPackageName.equals(packageName)) {
            importTypes.add(refPackageName + '.' + e.ref.name)
        }

        if (!e.arguments.isEmpty) {
            var joiner = new StringJoiner(",");
            for (param : e.arguments) {
                joiner.add(param.LiteralExpression.toString)
            }
            string += joiner.toString
        }
        string += ')'
        return string
    }
    
    def dispatch LiteralExpression(SizeExpression e){
        return e.value.LiteralExpression + '.size()'
    }
}
